#!/bin/sh

# Unblock the network by removing the blocklist of all network drivers,
# triggering udev events to load the drivers, and starting NetworkManager.
#
# See the "Network blocking" section in the "MAC address anonymization"
# design document for details:
# https://tails.net/contribute/design/MAC_address/

set -e
set -u
set -x

# Import tails_network_enabled()
# shellcheck source=tails-shell-library/tails-greeter.sh
. /usr/local/lib/tails-shell-library/tails-greeter.sh

if tails_network_enabled ; then
   /bin/rm -f /etc/modprobe.d/all-net-blocklist.conf
   /bin/touch /etc/modprobe.d
   # Make sure that the blocklist has disappeared from the filesystem
   /bin/sync --file-system /etc/modprobe.d
fi

# XXX: add debugging information for #9012 to the Journal
ls /etc/modprobe.d
/sbin/lsmod
ls -l /sys/class/net

# There's a chance that udev won't pick up quickly and automatically
# changes to /etc/modprobe.d, for example if it monitors that
# directory via its inode number at the time udev started: the inode
# number of that directory might have changed since (this is
# a documented possibility without overlayfs xino= mount option;
# for details, see #17258).
# So let's instruct udev to update its knowledge of the world.
echo "Asking systemd-udevd to reload databases..." >&2
udevadm control --reload
echo "systemd-udevd has reloaded its databases." >&2

# For debugging purposes, specifically to make it easier for us to
# append subsystems of devices which cause trouble to the list of
# excluded subsystems, we log all devices and their subsystems.
udevadm info --export-db | grep "P:\|E: SUBSYSTEM"

# Now we'll load any present network device previously blocked by
# the blocklist. In particular, the MAC spoofing udev rule should trigger
# for each network device added.
#
# We use --settle to block until the triggered events have finished.
# NetworkManager is started immediately after, and without the blocking
# behaviour there's a race between NM and the MAC spoof udev triggers.
# When NM takes control of some network device, some operations are not
# possible on the device, like MAC spoofing. Hence, if NM wins, the
# udev-triggered run of tails-spoof-mac will fail.
echo "Replaying udev events..." >&2

# Trigger udev events for all subsystems except some which are clearly
# not network-related. The list of subsystems was generated by running
#
#   udevadm info --export-db | grep SUBSYSTEM | sed 's/.*SUBSYSTEM=//' | sort -u
#
# on a Debian Sid system and a Tails QEMU VM (concatenated). Explicitly
# excluded are any subsystems which could potentially be network-related.
# Those are:
# - net (obviously)
# - pci, pci_bus, pci_express (for PCI network cards)
# - usb, usbmisc (for USB network cards)
# - platform (for embedded network controllers)
# - ieee80211 (for Wi-Fi controllers)
# - virtio, virtio-ports (for virtual network cards)
# - mmc_host (seems like SDIO/MMC Wi-Fi cards exist)
# - devlink (seems to be related to network devices)
# - mdio_bus (maybe some network cards use MDIO?)
# - scsi, scsi_device, scsi_generic, scsi_host (maybe some network cards use SCSI?)
# - wmi, wmi_bus (might be used by some network controllers?)
# - misc (might be used for some (virtual) network devices?)
# - rfkill (might be used for some network devices?)
timeout --verbose 120 udevadm trigger --verbose --settle --type=all --action=add \
  --subsystem-nomatch=acpi \
  --subsystem-nomatch=ata_device \
  --subsystem-nomatch=ata_link \
  --subsystem-nomatch=ata_port \
  --subsystem-nomatch=backlight \
  --subsystem-nomatch=bdi \
  --subsystem-nomatch=block \
  --subsystem-nomatch=bluetooth \
  --subsystem-nomatch=bsg \
  --subsystem-nomatch=clockevents \
  --subsystem-nomatch=clocksource \
  --subsystem-nomatch=container \
  --subsystem-nomatch=cpu \
  --subsystem-nomatch=dmi \
  --subsystem-nomatch="drm*" \
  --subsystem-nomatch=edac \
  --subsystem-nomatch=event_source \
  --subsystem-nomatch=firmware-attributes \
  --subsystem-nomatch=gpio \
  --subsystem-nomatch=graphics \
  --subsystem-nomatch=hdaudio \
  --subsystem-nomatch=hid \
  --subsystem-nomatch=hidraw \
  --subsystem-nomatch=hwmon \
  --subsystem-nomatch=i2c \
  --subsystem-nomatch=input \
  --subsystem-nomatch=iommu \
  --subsystem-nomatch=kfd \
  --subsystem-nomatch=leds \
  --subsystem-nomatch=machinecheck \
  --subsystem-nomatch=media \
  --subsystem-nomatch=mem \
  --subsystem-nomatch=memory \
  --subsystem-nomatch=memory_tiering \
  --subsystem-nomatch=msr \
  --subsystem-nomatch=node \
  --subsystem-nomatch=nvme \
  --subsystem-nomatch=nvme-generic \
  --subsystem-nomatch=nvmem \
  --subsystem-nomatch=nvme-subsystem \
  --subsystem-nomatch=pnp \
  --subsystem-nomatch=powercap \
  --subsystem-nomatch=power_supply \
  --subsystem-nomatch=regulator \
  --subsystem-nomatch=rtc \
  --subsystem-nomatch=serial-base \
  --subsystem-nomatch=serio \
  --subsystem-nomatch=sound \
  --subsystem-nomatch=thermal \
  --subsystem-nomatch=tpm \
  --subsystem-nomatch=tpmrm \
  --subsystem-nomatch=tty \
  --subsystem-nomatch=vc \
  --subsystem-nomatch=video4linux \
  --subsystem-nomatch=vtconsole \
  --subsystem-nomatch=wakeup \
  --subsystem-nomatch=watchdog \
  --subsystem-nomatch=workqueue

echo "replayed udev events." >&2

# It's not clear why, but the `udevadm trigger` command above returns
# before all the triggered events finished, even though we pass `--settle`.
# We call `udevadm settle` here to ensure that the events for the network
# devices have finished. That's important because the NetworkManager
# service is masked by the MAC spoofing udev rule if MAC spoofing fails,
# so we need to make sure the udev rule has finished before we start
# NetworkManager below.
echo "Waiting for udev events to settle..." >&2
udevadm settle
echo "udev events settled." >&2

# XXX: add debugging information for #9012 to the Journal
/sbin/lsmod
ls -l /sys/class/net

# Enable and start NetworkManager services
# No need to manually enable NetworkManager-dispatcher.service,
# as NetworkManager.service has "Also=NetworkManager-dispatcher.service"
# in its [Install] section.
# If tails-spoof-mac goes into panic mode but fails to disable the
# problematic device, the NetworkManager services will be masked.
systemctl enable NetworkManager.service NetworkManager-wait-online.service || :
systemctl start NetworkManager.service NetworkManager-dispatcher.service || :
systemctl --no-block start NetworkManager-wait-online.service || :
